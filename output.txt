Скрипт запущен в папке: C:\Users\ilyal\Desktop\coffee\data_base_cp

【 Папка: data_base_cp 】
Содержимое:
    my_proj_async/
    output.txt
    README.md

Файл: output.txt 
Содержимое:


Файл: README.md 
Содержимое:
#  Coffee Themed Merchandise Store

<img width="537" height="464" alt="image" src="https://github.com/user-attachments/assets/78594f84-b6b5-4557-92f8-964af862876d" />

Веб-приложение для продажи товаров кофейной тематики с системой авторизации и разделением ролей пользователей.

##  О проекте

Данный проект представляет собой полнофункциональный сервис по продаже вещей кофейной тематики, реализованный в виде веб-приложения на Streamlit. Система включает в себя разграничение прав доступа между администраторами и покупателями, управление товарами, поставками и продажами.

##  Основные возможности

###  Для всех пользователей
-  Система авторизации с разделением ролей
- Регистрация новых аккаунтов
- Просмотр каталога товаров
- Фильтрация товаров по категориям

###  Для администраторов
- Управление пользователями и правами доступа
- Добавление товаров, категорий и поставщиков
- Контроль цен с историей изменений
- Просмотр аналитики продаж

###  Для покупателей
- Покупка товаров
- Просмотр истории заказов
- Управление профилем

##  Структура базы данных

### Схема моделей данных

![Database Schema](https://github.com/user-attachments/assets/45426711-b63a-4a45-8b38-1646d3ba4caa)

### Описание таблиц

####  Основные таблицы

| Таблица | Назначение |
|---------|------------|
| categories | Категории товаров |
| products | Карточки товаров |
| suppliers | Информация о поставщиках |
| users | Данные пользователей системы |

####  Таблицы цен и аудита
| Таблица | Назначение |
|---------|------------|
| prices | Текущие и исторические цены |
| price_audit | История изменения цен |

####  Таблицы поставок
| Таблица | Назначение |
|---------|------------|
| deliveries | Информация о поставках |
| delivery_contents | Состав поставок |

####  Таблицы продаж
| Таблица | Назначение |
|---------|------------|
| sales | Информация о продажах |
| sales_details | Детали продаж |

##  Функциональность приложения

###  Авторизация и регистрация

Страница входа
- Вход в систему по логину и паролю
- Доступ к разным функциям в зависимости от роли

![Login Page](https://github.com/user-attachments/assets/932a65ee-6020-4872-9012-b3faf65ef9bb)

Регистрация нового пользователя
- Регистрация обычных пользователей
- Автоматическое присвоение роли "покупатель"

![Registration Page](https://github.com/user-attachments/assets/52661161-6b2d-4090-a2ff-ba740dae6a0f)

###  Панель администратора

Управление пользователями
- Просмотр списка пользователей
- Изменение прав доступа
- Блокировка/активация аккаунтов

![User Management](https://github.com/user-attachments/assets/40905a84-d6f5-42f1-b472-52127da33054)

Добавление пользователей
- Регистрация новых пользователей
- Назначение ролей (администратор/покупатель)

![Add Users](https://github.com/user-attachments/assets/c9e237c2-dcc5-474d-b9d8-7051882ca32c)

Управление товарами
- Добавление новых товаров
- Создание категорий
- Регистрация поставщиков

![Product Management](https://github.com/user-attachments/assets/ab5c4168-f450-4283-a54a-73770112ada2)

Обновление цен
- Изменение стоимости товаров
- Автоматическое ведение истории изменений

![Price Update](https://github.com/user-attachments/assets/a4d5c790-0e48-4c92-91e7-f14ad5fee617)

###  Функции покупателя

Каталог товаров
- Просмотр всего ассортимента
- Фильтрация по категориям
- Поиск товаров

![Product Catalog](https://github.com/user-attachments/assets/97ea5ba6-2132-4c5f-b3f0-f3f0542a9807)

##  Технологии

- Backend: Python, Streamlit
- Database: PostgreSQL/MySQL
- Authentication: Custom auth system
- Frontend: Streamlit components
- Security: Password hashing, role-based access


【 Папка: my_proj_async 】
Содержимое:
    migration/
    src/
    env.env

Файл: my_proj_async\env.env 
Содержимое:
DB_NAME=cpbdB_USER=cpbd
DB_PASSWORD=cpbd
DB_HOST=localhost
DB_PORT=5432
POOL_MIN_CONN=1
POOL_MAX_CONN=10

【 Папка: my_proj_async\migration 】
Содержимое:
    ddl.sql
    dml.sql

Файл: my_proj_async\migration\ddl.sql 
Содержимое:

-- Drop table

-- DROP TABLE categories;

CREATE TABLE categories (
	category_id serial4 NOT NULL,
	"name" varchar(512) NOT NULL,
	CONSTRAINT categories_pkey PRIMARY KEY (category_id)
);


-- public.price_audit определение

-- Drop table

-- DROP TABLE price_audit;

CREATE TABLE price_audit (
	id serial4 NOT NULL,
	barcode varchar(255) NULL,
	old_price numeric NULL,
	new_price numeric NULL,
	update_time timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT price_audit_pkey PRIMARY KEY (id)
);


-- public.suppliers определение

-- Drop table

-- DROP TABLE suppliers;

CREATE TABLE suppliers (
	supplier_id serial4 NOT NULL,
	"name" varchar(100) NOT NULL,
	phone varchar(20) NULL,
	address varchar(255) NULL,
	CONSTRAINT suppliers_pkey PRIMARY KEY (supplier_id)
);


-- public.users определение

-- Drop table

-- DROP TABLE users;

CREATE TABLE users (
	user_id serial4 NOT NULL,
	username varchar(50) NULL,
	password_hash varchar(255) NULL,
	"role" varchar(20) NULL,
	email varchar(100) NULL,
	active bool DEFAULT true NULL,
	CONSTRAINT users_email_key UNIQUE (email),
	CONSTRAINT users_pkey PRIMARY KEY (user_id),
	CONSTRAINT users_username_key UNIQUE (username)
);


-- public.deliveries определение

-- Drop table

-- DROP TABLE deliveries;

CREATE TABLE deliveries (
	delivery_id serial4 NOT NULL,
	supplier_id int4 NULL,
	delivery_date date NOT NULL,
	CONSTRAINT deliveries_pkey PRIMARY KEY (delivery_id),
	CONSTRAINT deliveries_supplier_id_fkey FOREIGN KEY (supplier_id) REFERENCES suppliers(supplier_id) ON DELETE CASCADE
);


-- public.products определение

-- Drop table

-- DROP TABLE products;

CREATE TABLE products (
	barcode varchar(20) NOT NULL,
	"name" varchar(512) NULL,
	package_size varchar(50) NULL,
	weight numeric NULL,
	category_id int4 NULL,
	CONSTRAINT products_pkey PRIMARY KEY (barcode),
	CONSTRAINT products_category_id_fkey FOREIGN KEY (category_id) REFERENCES categories(category_id) ON DELETE CASCADE
);


-- public.sales определение

-- Drop table

-- DROP TABLE sales;

CREATE TABLE sales (
	sale_id serial4 NOT NULL,
	user_id int4 NULL,
	total_sum numeric(10, 2) NULL,
	sale_date date NOT NULL,
	address varchar(255) NULL,
	phone_number varchar(15) NULL,
	CONSTRAINT sales_pkey PRIMARY KEY (sale_id),
	CONSTRAINT sales_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);


-- public.sales_details определение

-- Drop table

-- DROP TABLE sales_details;

CREATE TABLE sales_details (
	sale_id int4 NULL,
	barcode varchar(20) NULL,
	quantity int4 NOT NULL,
	price_per_piece numeric(10, 2) NULL,
	total_price numeric(10, 2) NULL,
	CONSTRAINT sales_details_barcode_fkey FOREIGN KEY (barcode) REFERENCES products(barcode) ON DELETE CASCADE,
	CONSTRAINT sales_details_sale_id_fkey FOREIGN KEY (sale_id) REFERENCES sales(sale_id) ON DELETE CASCADE
);


-- public.delivery_contents определение

-- Drop table

-- DROP TABLE delivery_contents;

CREATE TABLE delivery_contents (
	delivery_content_id serial4 NOT NULL,
	delivery_id int4 NULL,
	barcode varchar(20) NULL,
	quantity int4 NOT NULL,
	CONSTRAINT delivery_contents_pkey PRIMARY KEY (delivery_content_id),
	CONSTRAINT delivery_contents_barcode_fkey FOREIGN KEY (barcode) REFERENCES products(barcode) ON DELETE CASCADE,
	CONSTRAINT delivery_contents_delivery_id_fkey FOREIGN KEY (delivery_id) REFERENCES deliveries(delivery_id) ON DELETE CASCADE
);


-- public.prices определение

-- Drop table

-- DROP TABLE prices;

CREATE TABLE prices (
	price_id serial4 NOT NULL,
	barcode varchar(20) NULL,
	start_date date NOT NULL,
	end_date date NULL,
	price numeric NOT NULL,
	CONSTRAINT prices_pkey PRIMARY KEY (price_id),
	CONSTRAINT prices_barcode_fkey FOREIGN KEY (barcode) REFERENCES products(barcode) ON DELETE CASCADE
);


;

Файл: my_proj_async\migration\dml.sql 
Содержимое:
-- Добавление продуктов в таблицу Products с размерами упаковок (длина, ширина, высота)
INSERT INTO public.categories ("name") VALUES
	 ('кофе'),
	 ('вещи');

INSERT INTO public.products (barcode,"name",package_size,weight,category_id) VALUES
	 ('123456789012','Эфиопский кофе','0.1*0.05*0.01',50.0,1),
	 ('234567890123','Магнит в виде кофе','0.25*0.25*0.35',500.0,2),
	 ('345678901234','Бразильский кофе','0.2*0.15*0.05',150.0,1),
	 ('456789012345','Колумбийский кофе','0.2*0.1*0.02',100.0,1),
	 ('567890123456','Росскийский кофе','0.15*0.1*0.05',150.0,1),
	 ('678901234567','Брелок в виде кофе','0.2*0.2*0.3',1000.0,2),
	 ('789012345678','Подушка в виде кофе','0.25*0.25*0.35',500.0,2),
	 ('890123456789','Футболка с принтом кофе','0.2*0.2*0.3',250.0,2),
	 ('901234567890','Наклеки с кофе','0.15*0.1*0.05',200.0,2),
	 ('012345678901','Немецкое кофе','0.1*0.05*0.01',55.0,1);

INSERT INTO public.suppliers ("name",phone,address) VALUES
	 ('ООО "ПродуктыПлюс"','+7 495 123-45-67','Москва, ул. Ленина, д. 10'),
	 ('ЗАО "Вкусные Дары"','+7 812 234-56-78','Санкт-Петербург, ул. Пушкина, д. 20'),
	 ('ИП "Сити Продукт"','+7 831 345-67-89','Нижний Новгород, ул. Советская, д. 15'),
	 ('ООО "Питание и Удовольствие"','+7 863 456-78-90','Ростов-на-Дону, ул. Гагарина, д. 5'),
	 ('ЗАО "Сладкие Моменты"','+7 343 567-89-01','Екатеринбург, ул. Мира, д. 12'),
	 ('ИП "Товары для всех"','+7 495 678-90-12','Москва, ул. Тверская, д. 45'),
	 ('ООО "Свежие Продукты"','+7 831 789-01-23','Нижний Новгород, ул. Ленина, д. 7'),
	 ('ЗАО "Экологические продукты"','+7 863 890-12-34','Ростов-на-Дону, ул. Нахимова, д. 30'),
	 ('ИП "Качество и Удобство"','+7 343 901-23-45','Екатеринбург, ул. Белинского, д. 25'),
	 ('ООО "Еда с Любовью"','+7 812 012-34-56','Санкт-Петербург, ул. Некрасова, д. 8');


INSERT INTO public.prices (barcode,start_date,end_date,price) VALUES
	 ('123456789012','2024-11-01',NULL,50.0),
	 ('234567890123','2024-11-01',NULL,45.0),
	 ('345678901234','2024-11-01',NULL,60.0),
	 ('456789012345','2024-11-01',NULL,80.0),
	 ('567890123456','2024-11-01',NULL,70.0),
	 ('678901234567','2024-11-01',NULL,90.0),
	 ('789012345678','2024-11-01',NULL,50.0),
	 ('890123456789','2024-11-01',NULL,100.0),
	 ('901234567890','2024-11-01',NULL,120.0),
	 ('012345678901','2024-11-01',NULL,55.0);

INSERT INTO public.deliveries (supplier_id,delivery_date) VALUES
	 (1,'2023-09-01'),
	 (2,'2023-09-05'),
	 (3,'2023-09-15');

INSERT INTO public.delivery_contents (delivery_id,barcode,quantity) VALUES
	 (1,'123456789012',5),
	 (1,'234567890123',6),
	 (2,'345678901234',5),
	 (2,'456789012345',5),
	 (2,'567890123456',5),
	 (3,'678901234567',5),
	 (3,'789012345678',5),
	 (3,'890123456789',5),
	 (3,'901234567890',5),
	 (3,'012345678901',5);



【 Папка: my_proj_async\src 】
Содержимое:
    pages/
    repositories/
    services/
    __pycache__/
    env.env
    main.py
    settings.py

Файл: my_proj_async\src\env.env 
Содержимое:
DB_NAME=cofe
DB_USER=cofe
DB_PASSWORD=cofe
DB_HOST=localhost
DB_PORT=5432
POOL_MIN_CONN=1
POOL_MAX_CONN=10

Файл: my_proj_async\src\main.py 
Содержимое:
from pages.selling_products import show_selling_products_page
import streamlit as st
from pages.login import login, check_role
from pages.register import show_register_page  # Новая страница регистрации
from pages.user_management import user_rights, add_user_or_admin
from pages.add_products import add_products_admin
from pages.update_prices import update_price
from repositories.update_prices_products import create_trigger_and_function
import asyncio
import pandas as pd
# Обертка для вызова асинхронных функций в синхронном контексте Streamlit
def run_async_function(async_func, *args, **kwargs):
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    result = loop.run_until_complete(async_func(*args, **kwargs))
    loop.close()
    return result


# Асинхронная версия create_trigger_and_function
async def async_create_trigger_and_function():
    await create_trigger_and_function()


# Асинхронная логика главной функции
async def main_async():
    try:
        st.sidebar.title("Навигация")

    # Асинхронное создание триггера и функции
        await async_create_trigger_and_function()

        if "auth_token" not in st.session_state:
            page = st.sidebar.radio(
                "Выберите действие", ["Вход", "Регистрация"]
            )
            if page == "Вход":
                await login()
            elif page == "Регистрация":
                await show_register_page()
        else:
            if await check_role("user"):
                page = st.sidebar.radio(
                    "Перейти к странице",
                    ["Сделать заказ", "Выйти"],
                )
                if page == "Сделать заказ":
                    if "sales_table" not in st.session_state:
                        st.session_state.sales_table = pd.DataFrame(
                            columns=["Название продукта", "Barcode", "Количество", "Цена за штуку", "Суммарная цена"]
                        )

                    if "total_sum" not in st.session_state:
                        st.session_state.total_sum = 0.0
                    try:

                        await show_selling_products_page()
                    except Exception as e:
                        st.text(f"Internal server error: {e}")

                elif page == "Выйти":
                    exit_from_page = st.button("Выйти")
                    if exit_from_page:
                        st.session_state.pop("auth_token", None)
                        st.success("Вы вышли из системы")
            elif await check_role("admin"):
                page = st.sidebar.radio(
                    "Перейти к странице",
                    [
                        "Сделать заказ",
                        "Управление пользовательскими правами",
                        "Добавить пользователя или админа",
                        "Добавить товар, категорию, поставщика",
                        "Обновить цену",
                        "Выйти",
                    ],
                )
                if page == "Сделать заказ":
                    await show_selling_products_page()
                elif page == "Управление пользовательскими правами":
                    await user_rights()
                elif page == "Добавить пользователя или админа":
                    await add_user_or_admin()
                elif page == "Добавить товар, категорию, поставщика":
                    await add_products_admin()
                elif page == "Обновить цену":
                    await update_price()
                elif page == "Выйти":
                    exit_from_page = st.button("Выйти")
                    if exit_from_page:
                        st.session_state.pop("auth_token", None)
                        st.success("Вы вышли из системы")
    except Exception as e:
        st.text(f"Internal server error: {e}")

# Главная логика приложения
def main():
    run_async_function(main_async)


if __name__ == "__main__":
    main()


Файл: my_proj_async\src\settings.py 
Содержимое:
import os
from dotenv import load_dotenv

load_dotenv("env.env")

DB_CONFIG = {
    "database": os.getenv("DB_NAME"),
    "user": os.getenv("DB_USER"),
    "password": os.getenv("DB_PASSWORD"),
    "host": os.getenv("DB_HOST"),
    "port": os.getenv("DB_PORT"),
}

POOL_MIN_CONN = int(os.getenv("POOL_MIN_CONN", 1))
POOL_MAX_CONN = int(os.getenv("POOL_MAX_CONN", 10))


【 Папка: my_proj_async\src\pages 】
Содержимое:
    __pycache__/
    add_products.py
    login.py
    register.py
    selling_products.py
    update_prices.py
    user_management.py

Файл: my_proj_async\src\pages\add_products.py 
Содержимое:
import streamlit as st
import asyncio
from repositories.products_for_admin import check_product, check_supplier, check_category, \
    push_supplier, get_id_supplier, push_date, push_category, push_product, \
    get_id_category, push_delivery_contents, push_price, get_id_delivery


async def add_products_admin():
    st.title("Добавить товар, категорию или поставщика")

    st.title("Здесь вы можете определить существует ли такой продукт")
    barcode_product = st.text_input("Введите barcode товара")
    name_product = st.text_input("Введите название товара")
    weight_product = st.text_input("Введите вес товара")

    check_product_button = st.button("Проверить товар на складе")
    if check_product_button:
        if await check_product(barcode_product, name_product, weight_product):
            st.success(f"Такой товар есть!")
        else:
            st.success(f"Такого товара нету!")

    st.title("Здесь вы можете определить существует ли такой поставщик")
    phone_supplier = st.text_input("Введите телефон поставщика")
    name_supplier = st.text_input("Введите имя поставщика")

    check_supplier_button = st.button("Проверить поставщика")
    if check_supplier_button:
        if await check_supplier(name_supplier, phone_supplier):
            st.success(f"Такой поставщик есть!")
        else:
            st.success(f"Такого поставщика нету!")

    st.title("Здесь вы можете определить существует ли такая категория")
    name_category = st.text_input("Введите название категории")

    check_category_button = st.button("Проверить категорию")
    if check_category_button:
        if await check_category(name_category):
            st.success(f"Такая категория есть!")
        else:
            st.success(f"Такой категории нету!")

    st.title("Введите имя поставщика, телефон поставщика, адрес поставщика и дату поставки")
    phone_supplier = st.text_input("Введите телефон поставщик")
    name_supplier = st.text_input("Введите имя поставщик")
    address_supplier = st.text_input("Введите адрес поставщика")
    date_supply = st.text_input("Введите дату поставки")

    push_date_and_supplier_button = st.button("Добавить дату поставки и поставщика")

    if push_date_and_supplier_button:
        if not await check_supplier(name_supplier, phone_supplier):
            await push_supplier(name_supplier, phone_supplier, address_supplier)
        else:
            st.success(f"Такой поставщик существует!")
        id_supplier = await get_id_supplier(name_supplier)
        await push_date(id_supplier, date_supply)
        st.success(f"Поставка добавлена!")

    st.title("Введите категорию")
    name_category = st.text_input("Введите название категор")
    push_category_button = st.button("Добавьте категорию")

    if push_category_button:
        if not await check_category(name_category):
            await push_category(name_category)
            st.success(f"Категория добавлена!")
        else:
            st.success(f"Такая категория существует!")

    st.title("Узнать id последней поставки")
    get_id_delivery_button = st.button("Узнать id последней поставки")
    if get_id_delivery_button:
        id_delivery = await get_id_delivery()
        st.success(f"id последней поставки {id_delivery}")

    st.title("Введите товар и характеристики товара, который вы хотите добавить")
    quantity_product = st.text_input("Введите количество товара")
    barcode_product = st.text_input("Введите barcode товар")
    name_product = st.text_input("Введите название товар")
    weight_product = st.text_input("Введите вес товар")
    package_size_product = st.text_input("Введите размер товар")
    name_category = st.text_input("Введите название катег")
    delivery_id = st.text_input("Введите id поставк")
    start_date_product = st.text_input("Введите дату установки цен")
    price = st.text_input("Введите цену товара")

    push_products_button = st.button("Добавить товар")

    if push_products_button:
        if not await check_product(barcode_product, name_product, weight_product):
            if not await check_category(name_category):
                await push_category(name_category)
                st.success(f"Категория добавлена!")
            else:
                st.success(f"Такая категория существует!")
            id_category = await get_id_category(name_category)
            await push_product(barcode_product, name_product, package_size_product, weight_product, id_category)
            st.success(f"Новый товар добавлен!")
            await push_price(barcode_product, start_date_product, price)
            st.success(f"Цена добавлена!")

        else:
            st.success(f"Характеристики такого товара уже существуют!")

        await push_delivery_contents(delivery_id, barcode_product, quantity_product)
        st.success(f"Товар добавлен!")



Файл: my_proj_async\src\pages\login.py 
Содержимое:
import streamlit as st
import jwt
from jwt import DecodeError, ExpiredSignatureError
from services.auth import authenticate_user, active_user

SECRET_KEY = "your_secret_key"

async def login():
    st.title("Вход")

    username = st.text_input("Логин")
    password = st.text_input("Пароль", type="password")
    login_button = st.button("Войти")

    if login_button:
        # Асинхронная проверка пользователя
        rez = await active_user(username)
        if rez:
            token = await authenticate_user(username, password)
            if token:
                st.session_state["auth_token"] = token
                st.success("Вход выполнен!")
            else:
                st.error("Неверный логин или пароль")
        elif rez is None:
            st.error("Пользователя c таким именем не существует!")
        else:
            st.error("Пользователь с таким именем заблокирован!")

async def check_role(required_role: str) -> bool:
    token = st.session_state.get("auth_token")
    if not token:
        st.error("Вы не авторизованы")
        return False

    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        if payload["role"] != required_role:
            return False
        return True
    except (DecodeError, ExpiredSignatureError):
        st.error("Невалидный или просроченный токен")
        return False



Файл: my_proj_async\src\pages\register.py 
Содержимое:
import streamlit as st
import re
from repositories.users import add_user  # Асинхронная функция добавления пользователя


async def show_register_page():
    st.title("Регистрация пользователя")

    with st.form("register_form"):
        username = st.text_input("Введите логин")
        password = st.text_input("Введите пароль", type="password")
        confirm_password = st.text_input("Повторите пароль", type="password")
        role = "user"
        active = True
        email = st.text_input("Введите адрес электронной почты")
        submit_button = st.form_submit_button("Зарегистрироваться")

        if submit_button:
            # Проверка валидности данных
            if not username or not password or not confirm_password:
                st.warning("Все поля обязательны для заполнения.")
                return

            if not re.match(r"^[a-zA-Z0-9_]+$", username):
                st.error("Имя пользователя может содержать только буквы, цифры и _.")
                return

            if len(password) < 6:
                st.error("Пароль должен быть длиной не менее 6 символов.")
                return

            if password != confirm_password:
                st.error("Пароли не совпадают.")
                return

            # Добавление пользователя
            try:
                await add_user(username, password, role, email, active)
                st.success(f"Пользователь {username} успешно зарегистрирован!")
            except ValueError as e:
                st.error(str(e))




Файл: my_proj_async\src\pages\selling_products.py 
Содержимое:
import streamlit as st
import pandas as pd
from datetime import date
import random
from services.sales import SalesService  # Асинхронный сервис продаж
from repositories.products import get_count_product, get_products, get_products_filter, get_categories




if "sales_table" not in st.session_state:
    st.session_state.sales_table = pd.DataFrame(
        columns=["Название продукта", "Barcode", "Количество", "Цена за штуку", "Суммарная цена"]
    )

if "total_sum" not in st.session_state:
    st.session_state.total_sum = 0.0


def update_total_sum():
    """Обновление общей суммы заказа."""
    st.session_state.total_sum = st.session_state.sales_table["Суммарная цена"].sum()


async def get_everything_quantity_product(product_barcode):
    """Асинхронное получение доступного количества товара на складе."""
    return await get_count_product(product_barcode)


def get_quantity_product_from_basket(product_barcode):
    """Получение количества товара в корзине."""
    product_row = st.session_state.sales_table.loc[
        st.session_state.sales_table['Barcode'] == product_barcode
    ]
    if not product_row.empty:
        return product_row['Количество'].values[0]
    return 0


async def add_product_event(product_name, product_barcode, product_quantity, product_price):
    """Асинхронное добавление продукта в корзину."""
    everything_quantity_product = await get_everything_quantity_product(product_barcode)
    print(everything_quantity_product)
    everything_quantity_product = everything_quantity_product
    quantity_product_from_basket = get_quantity_product_from_basket(product_barcode)

    if everything_quantity_product >= product_quantity + quantity_product_from_basket:
        if any(st.session_state.sales_table['Barcode'] == product_barcode):
            st.session_state.sales_table.loc[
                st.session_state.sales_table['Barcode'] == product_barcode, 'Количество'
            ] += product_quantity
            st.session_state.sales_table.loc[
                st.session_state.sales_table['Barcode'] == product_barcode, 'Цена за штуку'
            ] = product_price
            st.session_state.sales_table.loc[
                st.session_state.sales_table['Barcode'] == product_barcode, 'Суммарная цена'
            ] = (
                st.session_state.sales_table.loc[
                    st.session_state.sales_table['Barcode'] == product_barcode, 'Количество'
                ]
                * float(product_price)
            )
            update_total_sum()
        else:
            new_row = pd.DataFrame(
                {
                    "Название продукта": [product_name],
                    "Barcode": [product_barcode],
                    "Количество": [product_quantity],
                    "Цена за штуку": [product_price],
                    "Суммарная цена": [float(product_quantity) * float(product_price)],
                }
            )
            st.session_state.sales_table = pd.concat(
                [st.session_state.sales_table, new_row], ignore_index=True
            )
            update_total_sum()
    else:
        st.error(
            f"Недостаточно товара на складе."
            f"Имеется только {everything_quantity_product} из {product_quantity + quantity_product_from_basket} требуемых."
        )


async def upload_sales(sales_table, total_sum, address, phone_number):
    """Асинхронная загрузка продажи."""
    sale_date = date(2024, random.randint(1, 12), random.randint(1, 28))
    sale_id = await SalesService().process_sale(
        sale_date, sales_table, total_sum, address, phone_number
    )
    st.write(f"Продажа за число {sale_date}")
    return sale_id


def clear_table_event():
    """Очистка корзины."""
    st.session_state.sales_table = pd.DataFrame(
        columns=["Название продукта", "Barcode", "Количество", "Цена за штуку", "Суммарная цена"]
    )
    update_total_sum()


async def show_selling_products_page():
    st.title("Продажа продуктов")

    categories = await get_categories()
    print(categories)#
    category_dict = {category['name']: category['category_id'] for category in categories}
    selected_category = st.selectbox("Выберите категорию", category_dict.keys())
    add_filter_btn = st.button("Применить фильтр")

    if add_filter_btn and category_dict[selected_category] != 0:
        products = await get_products_filter(category_dict[selected_category])
    elif category_dict[selected_category] != 0:
        print(1111)
        print(selected_category)
        products = await get_products_filter(category_dict[selected_category])
    else:
        products = await get_products()
        print(products)
    options = [
        f"{product['name']} | Штрих-код: | {product['barcode']} | Цена за штуку: | {product['price']} | руб."
        for product in products
    ]


    selected_product = st.selectbox("Выберите продукт", options)
    selected_name = selected_product.split(" | ")[0]
    selected_barcode = selected_product.split(" | ")[2]
    selected_price = selected_product.split(" | ")[4]

    quantity = st.number_input("Количество", min_value=1, max_value=100, value=1)
    add_product_btn = st.button("Добавить продукт")

    if add_product_btn:
        await add_product_event(selected_name, selected_barcode, quantity, selected_price)

    clear_table_btn = st.button("Очистить корзину")
    apply_btn = st.button("Сделать заказ")
    address = st.text_input("Введите адрес доставки")
    phone_number = st.text_input("Введите номер телефона")

    if clear_table_btn:
        clear_table_event()

    if apply_btn and len(st.session_state.sales_table) > 0:
        if not address or not phone_number:
            st.warning("Все поля обязательны для заполнения.")
            return

        for index, row in st.session_state.sales_table.iterrows():
            name = row["Название продукта"]
            barcode = row["Barcode"]
            quantity = row["Количество"]
            quantity_warehouse = await get_everything_quantity_product(barcode)
            quantity_warehouse = quantity_warehouse

            if quantity_warehouse < quantity:
                st.error(
                    f"Недостаточно {name} на складе. "
                    f"Пока вы выбирали, осталось только {quantity_warehouse}."
                )
                return

        sale_id = await upload_sales(
            st.session_state.sales_table, st.session_state.total_sum, address, phone_number
        )
        st.success(f"Продажа добавлена успешно! ID чека: {sale_id}")
        clear_table_event()
        update_total_sum()

    st.write("Добавленные товары:")
    st.dataframe(st.session_state.sales_table)
    st.write(f"**Сумма всего заказа:** {st.session_state.total_sum:.2f}")




Файл: my_proj_async\src\pages\update_prices.py 
Содержимое:
import streamlit as st
from repositories.products_for_admin import check_product
from repositories.update_prices_products import update_price_product
async def update_price():
    st.title("Здесь можно обновить цену")

    barcode_product = st.text_input("Введите barcode товара")
    weight_product = st.text_input("Введите вес товара")
    name_product = st.text_input("Введите название товара")
    start_date_product = st.text_input("Введите дату установки цены (в формате YYYY-MM-DD)")
    price = st.text_input("Введите цену товара")

    update_price_button = st.button("Обновить цену товара")

    if update_price_button:
        # Проверяем, заполнены ли все поля
        if not all([barcode_product, weight_product, name_product, start_date_product, price]):
            st.error("Пожалуйста, заполните все поля.")
            return

        try:
            price = float(price)
        except ValueError:
            st.error("Цена должна быть числом.")
            return

        # Проверяем наличие товара
        product_exists = await check_product(barcode_product, name_product, weight_product)
        if product_exists:
            st.success("Такой товар есть!")
            await update_price_product(barcode_product, start_date_product, price)
            st.success("Цена товара обновлена!")
        else:
            st.error("Такого товара нет!")



Файл: my_proj_async\src\pages\user_management.py 
Содержимое:
import streamlit as st
import re
import asyncio
from repositories.users import add_user, restrict_rights


async def user_rights():
    st.title("Выберите пользователя, которому вы хотите ограничить права доступа или восстановить права")
    username = st.text_input("Введите имя пользователя")
    right_button = st.selectbox(
        "Выберите TRUE, если вы хотите восстановить права, или FALSE, если вы хотите ограничить права",
        ["TRUE", "FALSE"]
    )
    button_apply = st.button("Применить изменения")
    if button_apply:
        right_value = True if right_button == "TRUE" else False
        right_change = await restrict_rights(right_value, username)
        if right_change:
            st.success("Пользовательские права были изменены!")
        else:
            st.error("Пользователя с таким именем не существует!")


async def add_user_or_admin():
    st.title("Добавить пользователя или администратора")

    with st.form("register_form"):
        username = st.text_input("Введите логин")
        password = st.text_input("Введите пароль", type="password")
        confirm_password = st.text_input("Повторите пароль", type="password")
        role = st.selectbox("Выберите роль", ["user", "admin"])
        email = st.text_input("Введите адрес электронной почты")
        submit_button = st.form_submit_button("Зарегистрировать")

        if submit_button:
            # Проверка валидности данных
            if not username or not password or not confirm_password or not role or not email:
                st.warning("Все поля обязательны для заполнения.")
                return

            if not re.match(r"^[a-zA-Z0-9_]+$", username):
                st.error("Имя пользователя может содержать только буквы, цифры и _.")
                return

            if len(password) < 6:
                st.error("Пароль должен быть длиной не менее 6 символов.")
                return

            if password != confirm_password:
                st.error("Пароли не совпадают.")
                return

            # Асинхронное добавление пользователя
            try:
                await add_user(username, password, role, email, active=True)
                st.success(f"Пользователь {username} успешно зарегистрирован!")
            except ValueError as e:
                st.error(str(e))



【 Папка: my_proj_async\src\pages\__pycache__ 】
Содержимое:
    add_products.cpython-312.pyc
    login.cpython-312.pyc
    register.cpython-312.pyc
    selling_products.cpython-312.pyc
    update_prices.cpython-312.pyc
    user_management.cpython-312.pyc

Файл: my_proj_async\src\pages\__pycache__\add_products.cpython-312.pyc 
Содержимое: [Бинарные данные]

Файл: my_proj_async\src\pages\__pycache__\login.cpython-312.pyc 
Содержимое: [Бинарные данные]

Файл: my_proj_async\src\pages\__pycache__\register.cpython-312.pyc 
Содержимое: [Бинарные данные]

Файл: my_proj_async\src\pages\__pycache__\selling_products.cpython-312.pyc 
Содержимое: [Бинарные данные]

Файл: my_proj_async\src\pages\__pycache__\update_prices.cpython-312.pyc 
Содержимое: [Бинарные данные]

Файл: my_proj_async\src\pages\__pycache__\user_management.cpython-312.pyc 
Содержимое: [Бинарные данные]

【 Папка: my_proj_async\src\repositories 】
Содержимое:
    __pycache__/
    connector.py
    products.py
    products_for_admin.py
    sales.py
    update_prices_products.py
    users.py

Файл: my_proj_async\src\repositories\connector.py 
Содержимое:
import psycopg2
from psycopg2 import pool
from settings import DB_CONFIG, POOL_MIN_CONN, POOL_MAX_CONN
import atexit

# Инициализация пула соединений
print("Initializing connection pool...")
connection_pool = psycopg2.pool.SimpleConnectionPool(
    POOL_MIN_CONN, POOL_MAX_CONN, **DB_CONFIG
)

# Обновленный контекстный менеджер для работы с соединением
def get_connection():
    """
    Контекстный менеджер для получения и возврата соединения в пул.
    """
    connection = connection_pool.getconn()
    try:
        yield connection  # генератор для использования с 'with'
    finally:
        connection_pool.putconn(connection)

# Функция для закрытия пула соединений
def close_connection_pool():
    """
    Закрывает все соединения в пуле при завершении работы приложения.
    """
    if connection_pool:
        connection_pool.closeall()
        print("Connection pool closed.")

# Регистрируем функцию, которая будет вызвана при завершении программы
def on_exit():
    print("Приложение завершено! Закрываем ресурсы...")
    close_connection_pool()

# Регистрируем обработчик завершения программы
atexit.register(on_exit)







from contextlib import contextmanager
from dotenv import load_dotenv
from psycopg2 import pool
import os
import asyncpg
import asyncio

load_dotenv("env.env")

DB_CONFIG = {
    "database": os.getenv("DB_NAME"),
    "user": os.getenv("DB_USER"),
    "password": os.getenv("DB_PASSWORD"),
    "host": os.getenv("DB_HOST"),
    "port": os.getenv("DB_PORT"),
}


# Инициализируем пул подключений
async def create_connection_pool():
    connection_pool: asyncpg.Pool = await asyncpg.create_pool(
        **DB_CONFIG,
        min_size=1,
        max_size=10,
    )
    return connection_pool


async def close_connection_pool(connection_pool: asyncpg.Pool):
    await connection_pool.close()
    print("Connection pool closed.")


async def get_products(connection_pool: asyncpg.Pool, barcode: str):
    query = """
        SELECT
            barcode,
            name,
            package_size,
            weight
        FROM
            shop.products
        WHERE
            barcode = $1
    """

    async with connection_pool.acquire() as connection:
        rows = await connection.fetch(query, barcode)

    for row in rows:
        print(row)

    print("get_products finished")


async def get_products_with_stmt(connection_pool: asyncpg.Pool, barcodes: list[str]):
    query = """
        SELECT
            barcode,
            name,
            package_size,
            weight
        FROM
            shop.products
        WHERE
            barcode = $1
    """

    async with connection_pool.acquire() as connection:
        stmt = await connection.prepare(query)

        for barcode in barcodes:
            rows = await stmt.fetch(barcode)

            for row in rows:
                print(row)

    print("get_products finished")


async def get_products_pro(connection_pool: asyncpg.Pool, barcodes: tuple[str]):
    query = """
        SELECT
            barcode,
            name,
            package_size,
            weight
        FROM
            shop.products
        WHERE
            barcode = ANY($1)
    """

    async with connection_pool.acquire() as connection:
        rows = await connection.fetch(query, barcodes)

    for row in rows:
        print(row)

    print("get_products finished")


async def example_executemany(connection_pool: asyncpg.Pool):
    query = """
        INSERT INTO shop.products
            (barcode, name, package_size, weight)
        VALUES
            ($1, $2, $3, $4);
    """
    params = [
        ("12345642121", "Test Product asyncpg executemany 1", "1*1*1cm", 10.0),
        ("12345678911", "Test Product asyncpg executemany 2", "1*1*1cm", 10.0),
    ]
    async with connection_pool.acquire() as connection:
        await connection.executemany(query, params)


async def example_delete(connection_pool: asyncpg.Pool, barcodes: tuple[str]):
    query = """
        DELETE FROM shop.products
        WHERE
            barcode = ANY($1)
    """

    async with connection_pool.acquire() as connection:
        await connection.execute(query, barcodes)


async def main():
    connection_pool: asyncpg.Pool = await create_connection_pool()

    await example_executemany(connection_pool)
    await get_products_pro(connection_pool, ("12345642121", "12345678911"))

    await example_delete(connection_pool, ("12345642121", "12345678911"))
    await get_products_pro(connection_pool, ("12345642121", "12345678911"))

    await close_connection_pool(connection_pool)


if __name__ == "__main__":
    asyncio.run(main())

Файл: my_proj_async\src\repositories\products.py 
Содержимое:
import asyncpg
from settings import DB_CONFIG


async def get_products():
    print("Получение продуктов")
    query = """
        SELECT p.name, p.barcode, pr.price
        FROM products p
        JOIN prices pr 
        ON p.barcode = pr.barcode;
    """
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            products = await conn.fetch(query)
            return [dict(record) for record in products]


async def get_products_filter(id_category):
    print("Получение продуктов фильтра")
    query = """
        SELECT p.name, p.barcode, pr.price
        FROM products p
        JOIN prices pr 
        ON p.barcode = pr.barcode
        WHERE category_id = $1;
    """
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            products = await conn.fetch(query, id_category)
            return [dict(record) for record in products]


async def get_categories() -> list[dict]:
    print("Получение категорий продуктов")
    query = "SELECT name, category_id FROM categories;"
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            categories = await conn.fetch(query)
            print(categories)
            return [dict(record) for record in categories]


async def get_count_product(barcode) -> int:
    print("Получение количества продукта по штрихкоду")
    query = """
        SELECT COALESCE(dc.quantity, 0) - COALESCE(sd.quantity, 0) AS remaining_quantity
        FROM (SELECT barcode, SUM(quantity) AS quantity FROM delivery_contents GROUP BY barcode) AS dc
        LEFT JOIN (SELECT barcode, SUM(quantity) AS quantity FROM sales_details GROUP BY barcode) AS sd
        ON dc.barcode = sd.barcode
        WHERE dc.barcode = $1;
    """
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            result = await conn.fetchval(query, barcode)
            return result if result is not None else 0


Файл: my_proj_async\src\repositories\products_for_admin.py 
Содержимое:
import asyncpg
from settings import DB_CONFIG
from datetime import datetime


async def check_product(barcode, name, weight):
    query_check = "SELECT COUNT(*) FROM products WHERE barcode = $1 AND name = $2 AND weight = $3;"
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            count = await conn.fetchval(query_check, barcode, name, weight)
            return count > 0


async def check_supplier(name, phone):
    query_check = "SELECT COUNT(*) FROM suppliers WHERE name = $1 AND phone = $2;"
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            count = await conn.fetchval(query_check, name, phone)
            return count > 0


async def check_category(name):
    query_check = "SELECT COUNT(*) FROM categories WHERE name = $1;"
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            count = await conn.fetchval(query_check, name)
            return count > 0


async def push_supplier(name, phone, address):
    query = """
        INSERT INTO suppliers (name, phone, address)
        VALUES ($1, $2, $3);
    """
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            await conn.execute(query, name, phone, address)


async def get_id_supplier(name):
    query = """SELECT supplier_id FROM suppliers WHERE name = $1;"""
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            result = await conn.fetchval(query, name)
            return result


async def get_id_category(name):
    query = """SELECT category_id FROM categories WHERE name = $1;"""
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            result = await conn.fetchval(query, name)
            return result


async def push_date(supplier_id, delivery_date):
    query = """
        INSERT INTO deliveries (supplier_id, delivery_date)
        VALUES ($1, $2);
    """
    delivery_date = datetime.strptime(delivery_date, '%Y-%m-%d').date()
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            await conn.execute(query, supplier_id, delivery_date)


async def push_category(name):
    query = """
        INSERT INTO categories (name)
        VALUES ($1);
    """
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            await conn.execute(query, name)


async def get_id_delivery():
    query = """SELECT MAX(delivery_id) FROM deliveries;"""
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            result = await conn.fetchval(query)
            return result


async def push_product(barcode, name, package_size, weight, category_id):
    query = """
        INSERT INTO products (barcode, name, package_size, weight, category_id)
        VALUES ($1, $2, $3, $4, $5);
    """
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            await conn.execute(query, barcode, name, package_size, weight, category_id)


async def push_delivery_contents(delivery_id, barcode, quantity):
    query = """
        INSERT INTO delivery_contents (delivery_id, barcode, quantity)
        VALUES ($1, $2, $3);
    """
    delivery_id = int(delivery_id)
    quantity = int(quantity)
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            await conn.execute(query, delivery_id, barcode, quantity)


async def push_price(barcode, start_date, price):
    query = """
        INSERT INTO prices (barcode, start_date, price)
        VALUES ($1, $2, $3);
    """
    start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            await conn.execute(query, barcode, start_date, price)


Файл: my_proj_async\src\repositories\sales.py 
Содержимое:
from pandas import DataFrame
import asyncpg
from settings import DB_CONFIG
from datetime import date


async def add_sale(user_id: int, sale_date: date, total_sum: float, address: str, phone_number: str) -> int:
    """
    Добавляет запись о продаже в таблицу sales и возвращает идентификатор добавленной продажи.
    """
    total_sum = float(total_sum)
    query = """
        INSERT INTO sales (user_id, total_sum, sale_date, address, phone_number)
        VALUES ($1, $2, $3, $4, $5) RETURNING sale_id;
    """
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            sale_id = await conn.fetchval(query, user_id, total_sum, sale_date, address, phone_number)
            return sale_id


async def add_sale_details(sales: DataFrame) -> None:
    """
    Добавляет детали продаж в таблицу sales_details на основе DataFrame.
    """
    query = """
        INSERT INTO sales_details (sale_id, barcode, quantity, price_per_piece, total_price)
        VALUES ($1, $2, $3, $4, $5);
    """
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            # Преобразуем DataFrame в список кортежей для передачи в executemany
            records = sales[["sale_id", "barcode", "quantity", "price_per_piece", "total_price"]].to_records(index=False)
            await conn.executemany(query, records)


Файл: my_proj_async\src\repositories\update_prices_products.py 
Содержимое:
import asyncpg
from settings import DB_CONFIG
from datetime import datetime


async def create_trigger_and_function():
    # SQL-запрос для создания функции триггера
    trigger_function_sql = """
    CREATE OR REPLACE FUNCTION audit_price_change() 
    RETURNS TRIGGER AS $$
    BEGIN
        INSERT INTO price_audit (barcode, old_price, new_price)
        VALUES (OLD.barcode, OLD.price, NEW.price);
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql; 
    """

    # SQL-запрос для создания триггера
    trigger_sql = """
    CREATE TRIGGER price_update_trigger
    AFTER UPDATE ON prices
    FOR EACH ROW
    WHEN (OLD.price IS DISTINCT FROM NEW.price)
    EXECUTE FUNCTION audit_price_change();
    """

    try:
        async with asyncpg.create_pool(**DB_CONFIG) as pool:
            async with pool.acquire() as conn:
                # Создать функцию триггера
                await conn.execute(trigger_function_sql)
                # Создать триггер
                await conn.execute(trigger_sql)
                print("Trigger and function created successfully.")
    except Exception as e:
        print(f"Error creating trigger and function: {e}")


async def update_price_product(barcode: str, start_date: str, price: float):
    query_update = "UPDATE prices SET start_date = $1, price = $2 WHERE barcode = $3;"
    start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
    try:
        async with asyncpg.create_pool(**DB_CONFIG) as pool:
            async with pool.acquire() as conn:
                await conn.execute(query_update, start_date, price, barcode)
                print("Price updated successfully.")
    except Exception as e:
        print(f"Error updating price: {e}")


Файл: my_proj_async\src\repositories\users.py 
Содержимое:
from services.auth import hash_password
import asyncpg
from settings import DB_CONFIG


async def add_user(username: str, password: str, role: str = "user", email: str = "non@yandex.ru", active: bool = True):
    query_check = "SELECT COUNT(*) FROM users WHERE username = $1;"
    query_email = "SELECT COUNT(*) FROM users WHERE email = $1;"
    query_insert = "INSERT INTO users (username, password_hash, role, email, active) VALUES ($1, $2, $3, $4, $5);"

    # Подключение к базе данных
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            # Проверка, существует ли пользователь
            count = await conn.fetchval(query_check, username)
            if count > 0:
                raise ValueError("Пользователь с таким логином уже существует.")
            count = await conn.fetchval(query_email, email)
            if count > 0:
                raise ValueError("Пользователь с такой электронной почтой существует.")

            # Хеширование пароля
            password_hash = hash_password(password)

            # Сохранение пользователя
            await conn.execute(query_insert, username, password_hash, role, email, active)


async def restrict_rights(right: bool, username: str):
    query_check = "SELECT COUNT(*) FROM users WHERE username = $1;"
    query_update = "UPDATE users SET active = $1 WHERE username = $2;"

    # Подключение к базе данных
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            # Проверка, существует ли пользователь
            count = await conn.fetchval(query_check, username)
            if count == 0:
                return False

            # Обновление прав
            await conn.execute(query_update, right, username)
            return True



【 Папка: my_proj_async\src\repositories\__pycache__ 】
Содержимое:
    connector.cpython-312.pyc
    products.cpython-312.pyc
    products_for_admin.cpython-312.pyc
    sales.cpython-312.pyc
    update_prices_products.cpython-312.pyc
    users.cpython-312.pyc

Файл: my_proj_async\src\repositories\__pycache__\connector.cpython-312.pyc 
Содержимое: [Бинарные данные]

Файл: my_proj_async\src\repositories\__pycache__\products.cpython-312.pyc 
Содержимое: [Бинарные данные]

Файл: my_proj_async\src\repositories\__pycache__\products_for_admin.cpython-312.pyc 
Содержимое: [Бинарные данные]

Файл: my_proj_async\src\repositories\__pycache__\sales.cpython-312.pyc 
Содержимое: [Бинарные данные]

Файл: my_proj_async\src\repositories\__pycache__\update_prices_products.cpython-312.pyc 
Содержимое: [Бинарные данные]

Файл: my_proj_async\src\repositories\__pycache__\users.cpython-312.pyc 
Содержимое: [Бинарные данные]

【 Папка: my_proj_async\src\services 】
Содержимое:
    __pycache__/
    auth.py
    sales.py

Файл: my_proj_async\src\services\auth.py 
Содержимое:
import bcrypt
import jwt
import datetime
import asyncpg
from settings import DB_CONFIG

# Секретный ключ для подписания JWT
SECRET_KEY = "your_secret_key"  # Замените на ваш собственный ключ

# --- Функции для работы с паролями ---
def hash_password(password: str) -> str:
    """
    Хеширует пароль с использованием bcrypt.
    """
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')


def verify_password(password: str, password_hash: str) -> bool:
    """
    Проверяет соответствие пароля и хеша.
    """
    return bcrypt.checkpw(password.encode('utf-8'), password_hash.encode('utf-8'))


# --- Функции для работы с JWT ---
def generate_jwt(user_id: int, role: str) -> str:
    """
    Генерирует JWT-токен с данными пользователя.
    """
    payload = {
        "user_id": user_id,
        "role": role,
        "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1),  # Срок действия токена - 1 час
    }
    return jwt.encode(payload, SECRET_KEY, algorithm="HS256")


def decode_jwt(token: str) -> dict:
    """
    Расшифровывает JWT-токен и возвращает полезную нагрузку.
    """
    return jwt.decode(token, SECRET_KEY, algorithms=["HS256"])


# --- Асинхронная функция для аутентификации ---
async def authenticate_user(username: str, password: str):
    """
    Аутентифицирует пользователя по имени и паролю.
    Возвращает JWT-токен, если аутентификация успешна, иначе None.
    """
    query = "SELECT user_id, password_hash, role FROM users WHERE username = $1;"
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            user = await conn.fetchrow(query, username)
            if user:
                user_id, password_hash, role = user["user_id"], user["password_hash"], user["role"]
                if verify_password(password, password_hash):
                    return generate_jwt(user_id, role)
    return None


# --- Асинхронная функция проверки активности пользователя ---
async def active_user(username: str):
    """
    Проверяет активность пользователя.
    Возвращает статус активности (True/False), если пользователь существует;
    иначе возвращает None.
    """
    query = "SELECT active FROM users WHERE username = $1;"
    async with asyncpg.create_pool(**DB_CONFIG) as pool:
        async with pool.acquire() as conn:
            result = await conn.fetchval(query, username)
            return result  # Возвращает True/False или None, если пользователь не найден


Файл: my_proj_async\src\services\sales.py 
Содержимое:
from datetime import datetime
from pandas import DataFrame
import jwt
from jwt import DecodeError, ExpiredSignatureError
import streamlit as st

# Импорт асинхронных функций
from repositories.sales import add_sale, add_sale_details  # Предполагается, что они асинхронные


class SalesService:
    async def process_sale(self, sale_date: datetime, items: DataFrame, total_sum, address, phone_number) -> int:
        """
        Обработка продажи: сохраняет данные о продаже и деталях продажи.
        """
        # Переименовываем колонки DataFrame для базы данных
        items = items.rename(
            columns={
                "Количество": "quantity",
                "Barcode": "barcode",
                "Цена за штуку": "price_per_piece",
                "Суммарная цена": "total_price",
            }
        )

        SECRET_KEY = "your_secret_key"
        token = st.session_state.get("auth_token")

        if not token:
            st.error("Вы не авторизованы")
            return False

        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
            user_id = payload["user_id"]
        except (DecodeError, ExpiredSignatureError):
            st.error("Невалидный или просроченный токен")
            return False

        # Асинхронное добавление продажи
        sale_id = await add_sale(user_id, sale_date, total_sum, address, phone_number)

        # Добавление ID продажи в DataFrame
        items["sale_id"] = sale_id

        # Асинхронное добавление деталей продажи
        await add_sale_details(items)

        return sale_id


【 Папка: my_proj_async\src\services\__pycache__ 】
Содержимое:
    auth.cpython-312.pyc
    sales.cpython-312.pyc

Файл: my_proj_async\src\services\__pycache__\auth.cpython-312.pyc 
Содержимое: [Бинарные данные]

Файл: my_proj_async\src\services\__pycache__\sales.cpython-312.pyc 
Содержимое: [Бинарные данные]

【 Папка: my_proj_async\src\__pycache__ 】
Содержимое:
    settings.cpython-312.pyc

Файл: my_proj_async\src\__pycache__\settings.cpython-312.pyc 
Содержимое: [Бинарные данные]


========================================
Сканирование завершено успешно!